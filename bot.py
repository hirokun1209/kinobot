# OCR BOTï¼ˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«é€šçŸ¥ä»˜ã + HTTPã‚µãƒ¼ãƒãƒ¼ã§UptimeRobotå¯¾å¿œï¼‰
import os
import discord
import io
import cv2
import re
import asyncio
import numpy as np
from paddleocr import PaddleOCR
from datetime import datetime, timedelta, timezone
from PIL import Image
from fastapi import FastAPI
import uvicorn
from threading import Thread

# =======================
# ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³è¨­å®š
# =======================
JST = timezone(timedelta(hours=9))

# =======================
# BOTè¨­å®š
# =======================
TOKEN = os.getenv("DISCORD_TOKEN")
NOTIFY_CHANNEL_ID = int(os.getenv("NOTIFY_CHANNEL_ID", "0"))
READABLE_CHANNEL_IDS = [int(x) for x in os.getenv("ALLOWED_CHANNEL_IDS", "").split(",") if x.strip().isdigit()]
if not TOKEN:
    raise ValueError("âŒ DISCORD_TOKEN ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼")

intents = discord.Intents.default()
intents.message_content = True
client = discord.Client(intents=intents)

# =======================
# FastAPI HTTP ã‚µãƒ¼ãƒãƒ¼ï¼ˆã‚¹ãƒªãƒ¼ãƒ—é˜²æ­¢ï¼‰
# =======================
app = FastAPI()

from fastapi.responses import JSONResponse

@app.get("/")
@app.get("/ping")
@app.get("/ping/")
def root():
    return JSONResponse(content={"status": "ok"})

def run_server():
    import time
    time.sleep(3)  # ã‚µãƒ¼ãƒ“ã‚¹å®‰å®šã®ãŸã‚ã«3ç§’é…å»¶
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)

# =======================
# OCRåˆæœŸåŒ–
# =======================
ocr = PaddleOCR(use_angle_cls=True, lang='japan')

# =======================
# ç®¡ç†æ§‹é€ 
# =======================
pending_places = {}
summary_blocks = []
active_tasks = set()
sent_notifications = set()
SKIP_NOTIFY_START = 2
SKIP_NOTIFY_END = 14

# =======================
# éå»äºˆå®šã®è‡ªå‹•å‰Šé™¤
# =======================
EXPIRE_GRACE = timedelta(minutes=2)

async def remove_expired_entries():
    now = now_jst()
    # pending_placesã®å‰Šé™¤
    for k, (dt, *_rest) in list(pending_places.items()):
        if dt + EXPIRE_GRACE < now:
            del pending_places[k]
    # summary_blocksã®å‰Šé™¤ã¨é€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤
    for block in list(summary_blocks):
        block["events"] = [ev for ev in block["events"] if ev[0] + EXPIRE_GRACE >= now]
        if block["msg"] and block["max"] + EXPIRE_GRACE < now:
            try:
                await block["msg"].delete()
            except:
                pass
            block["msg"] = None
        if not block["events"]:
            summary_blocks.remove(block)
    # ã‚¿ã‚¹ã‚¯ã®å‰Šé™¤
    for task in list(active_tasks):
        if task.done(): continue
        try:
            unlock_dt = task.get_coro().cr_frame.f_locals.get("unlock_dt")
            if isinstance(unlock_dt, datetime) and unlock_dt + EXPIRE_GRACE < now:
                task.cancel()
        except:
            pass

# =======================
# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
# =======================
# =======================
# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ç¾¤
# =======================

# ç¾åœ¨æ™‚åˆ»ï¼ˆJSTï¼‰
def now_jst():
    return datetime.now(JST)

# ãƒˆãƒƒãƒ—å³ã®æ™‚é–“éƒ¨åˆ†ã®åˆ‡ã‚Šå–ã‚Š
def crop_top_right(img):
    h, w = img.shape[:2]
    return img[0:int(h*0.2), int(w*0.7):]

# ä¸­å¤®ã‚¨ãƒªã‚¢ã®åˆ‡ã‚Šå–ã‚Šï¼ˆè¶ŠåŸŸé§é¨å ´ãªã©ï¼‰
def crop_center_area(img):
    h, w = img.shape[:2]
    return img[int(h*0.35):int(h*0.65), :]

# OCRã§ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡º
def extract_text_from_image(img):
    result = ocr.ocr(img, cls=True)
    return [line[1][0] for line in result[0]] if result and result[0] else []

# s1234 ã‚’æŠ½å‡ºï¼ˆã‚µãƒ¼ãƒãƒ¼ç•ªå·ï¼‰
def extract_server_number(center_texts):
    for t in center_texts:
        m = re.search(r"[sS](\d{3,4})", t)
        if m:
            return m.group(1)
    return None

# æ™‚é–“ã®åŠ ç®—ï¼ˆå…æˆ¦æ™‚é–“ã«åŠ ç®—ï¼‰
def add_time(base_time_str, duration_str):
    today = now_jst().date()
    try:
        base_time = datetime.strptime(base_time_str, "%H:%M:%S").time()
    except:
        return None, None
    base_dt = datetime.combine(today, base_time, tzinfo=JST)

    # 00:00:00ã€œ02:00:01 ã¯ç¿Œæ—¥ã¨ã—ã¦æ‰±ã†
    if base_time < datetime.strptime("02:00:01", "%H:%M:%S").time():
        base_dt += timedelta(days=1)

    parts = duration_str.split(":")
    if len(parts) == 3:
        h, m, s = map(int, parts)
    elif len(parts) == 2:
        h, m, s = 0, *map(int, parts)
    else:
        return None, None
    dt = base_dt + timedelta(hours=h, minutes=m, seconds=s)
    return dt, dt.strftime("%H:%M:%S")
# =======================
# é€šçŸ¥å‡¦ç†ï¼ˆæŠœç²‹ï¼‰
# =======================
async def schedule_notification(unlock_dt, text, channel):
    if unlock_dt <= now_jst():
        return
    if not (8 <= unlock_dt.hour or unlock_dt.hour < 2):
        return
    if text.startswith("å¥ªå–"):
        if not is_within_5_minutes_of_another(unlock_dt):
            t = unlock_dt - timedelta(minutes=2)
            if t > now_jst() and (text, "2min") not in sent_notifications:
                sent_notifications.add((text, "2min"))
                await asyncio.sleep((t - now_jst()).total_seconds())
                msg = await channel.send(f"â° {text} **2åˆ†å‰ã§ã™ï¼ï¼**")
                await asyncio.sleep(120)
                await msg.delete()
        t15 = unlock_dt - timedelta(seconds=15)
        if t15 > now_jst() and (text, "15s") not in sent_notifications:
            sent_notifications.add((text, "15s"))
            await asyncio.sleep((t15 - now_jst()).total_seconds())
            msg = await channel.send(f"â° {text} **15ç§’å‰ã§ã™ï¼ï¼**")
            await asyncio.sleep(120)
            await msg.delete()

# =======================
# è‡ªå‹•ãƒªã‚»ãƒƒãƒˆï¼ˆé€šçŸ¥ãªã—ï¼‰
# =======================
async def daily_reset_task():
    await client.wait_until_ready()
    while not client.is_closed():
        now = now_jst()
        next_reset = datetime.combine(now.date(), datetime.strptime("02:00:00", "%H:%M:%S").time(), tzinfo=JST)
        if now >= next_reset:
            next_reset += timedelta(days=1)
        await asyncio.sleep((next_reset - now).total_seconds())
        pending_places.clear()
        summary_blocks.clear()
        sent_notifications.clear()
        for task in list(active_tasks):
            task.cancel()
        active_tasks.clear()

# =======================
# å®šæœŸã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
# =======================
async def periodic_cleanup_task():
    await client.wait_until_ready()
    while not client.is_closed():
        await remove_expired_entries()
        await asyncio.sleep(60)

        
# =======================
# ã‚³ãƒãƒ³ãƒ‰ãƒ™ãƒ¼ã‚¹ã®ãƒªã‚»ãƒƒãƒˆ
# =======================
async def reset_all(message):
    pending_places.clear()
    summary_blocks.clear()
    sent_notifications.clear()
    for task in list(active_tasks):
        task.cancel()
    active_tasks.clear()
    await message.channel.send("âœ… å…¨ã¦ã®äºˆå®šã¨é€šçŸ¥ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ")

# =======================
# Discordã‚¤ãƒ™ãƒ³ãƒˆ
# =======================
@client.event
async def on_ready():
    print("âœ… ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸï¼")
    print(f"ğŸ“Œ é€šçŸ¥ãƒãƒ£ãƒ³ãƒãƒ«: {NOTIFY_CHANNEL_ID}")
    print(f"ğŸ“Œ èª­ã¿å–ã‚Šè¨±å¯ãƒãƒ£ãƒ³ãƒãƒ«: {READABLE_CHANNEL_IDS}")
    asyncio.create_task(daily_reset_task())  # âœ… è‡ªå‹•ãƒªã‚»ãƒƒãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼èµ·å‹•
    asyncio.create_task(periodic_cleanup_task())  # âœ… éå»äºˆå®šã®å‰Šé™¤ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼èµ·å‹•
        
@client.event
async def on_message(message):
    if message.author.bot or message.channel.id not in READABLE_CHANNEL_IDS:
        return

    channel = client.get_channel(NOTIFY_CHANNEL_ID)

    if message.content.strip() == "!reset":
        await reset_all(message)
        return

    if message.content.strip() == "!debug":
        if pending_places:
            lines = ["âœ… ç¾åœ¨ã®ç™»éŒ²ã•ã‚ŒãŸäºˆå®š:"]
            lines += [f"ãƒ»{v[1]}" for v in sorted(pending_places.values(), key=lambda x: x[0])]
            await message.channel.send("\n".join(lines))
        else:
            await message.channel.send("âš ï¸ ç™»éŒ²ã•ã‚ŒãŸäºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“")
        return

    manual = re.findall(r"\b(\d{3,4})-(\d+)-(\d{2}:\d{2}:\d{2})\b", message.content)
    if manual:
        for server, place, t in manual:
            if len(server) == 3:
                server = "1" + server
            mode = "è­¦å‚™" if server == "1268" else "å¥ªå–"
            txt = f"{mode} {server}-{place}-{t}"
            dt = datetime.combine(now_jst().date(), datetime.strptime(t, "%H:%M:%S").time(), tzinfo=JST)
            if txt not in pending_places:
                pending_places[txt] = (dt, txt, server, now_jst())
                await message.channel.send(f"âœ…æ‰‹å‹•ç™»éŒ²:{txt}")
                task = asyncio.create_task(handle_new_event(dt, txt, channel))
                active_tasks.add(task)
                task.add_done_callback(lambda t: active_tasks.discard(t))
                if txt.startswith("å¥ªå–"):
                    task2 = asyncio.create_task(schedule_notification(dt, txt, channel))
                    active_tasks.add(task2)
                    task2.add_done_callback(lambda t: active_tasks.discard(t))
        return

    if message.attachments:
        status = await message.channel.send("ğŸ”„è§£æä¸­â€¦")
        new_results = []
        for a in message.attachments:
            b = await a.read()
            img = Image.open(io.BytesIO(b)).convert("RGB")
            np_img = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)
            top = crop_top_right(np_img)
            center = crop_center_area(np_img)
            top_txts = extract_text_from_image(top)
            center_txts = extract_text_from_image(center)
            parsed = parse_multiple_places(center_txts, top_txts)
            for dt, txt in parsed:
                if txt not in pending_places:
                    pending_places[txt] = (dt, txt, "", now_jst())
                    new_results.append(txt)
                    task = asyncio.create_task(handle_new_event(dt, txt, channel))
                    active_tasks.add(task)
                    task.add_done_callback(lambda t: active_tasks.discard(t))
                    if txt.startswith("å¥ªå–"):
                        task2 = asyncio.create_task(schedule_notification(dt, txt, channel))
                        active_tasks.add(task2)
                        task2.add_done_callback(lambda t: active_tasks.discard(t))
        await status.edit(content=(
            "âœ… OCRèª­ã¿å–ã‚Šå®Œäº†ï¼ç™»éŒ²ã•ã‚ŒãŸäºˆå®š:\n" + "\n".join([f"ãƒ»{txt}" for txt in new_results])
            if new_results else "âš ï¸ OCRå‡¦ç†å®Œäº†ã—ã¾ã—ãŸãŒã€æ–°ã—ã„äºˆå®šã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"
        ))

# =======================
# èµ·å‹•
# =======================
import asyncio

async def start_discord_bot():
    await client.start(TOKEN)

async def main():
    # FastAPIã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§èµ·å‹•
    loop = asyncio.get_event_loop()
    loop.run_in_executor(None, run_server)
    
    # Discord bot ã‚’é–‹å§‹ï¼ˆclient.run ã§ã¯ãªã startï¼‰
    await start_discord_bot()

if __name__ == "__main__":
    asyncio.run(main())